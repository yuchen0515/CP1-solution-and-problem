# Quiz 04 解答——木板維修大師
> [name=王老師]

<iframe src="https://drive.google.com/file/d/1P1puWfgwXIx61Wp0rYnUfBqGuMtqxH1w/preview" width="640" height="480"></iframe>


## 評測主函式

* **board.h**

```cpp=
#pragma once

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

int needed (int *center[], int n);
// center: each element points to an element of "board"
// n: number of elements in "center"
```

* **main.c**
> 評測時，是用該主函式，呼叫同學的函式檔執行\
> 只需"看過"是怎麼運行的，不必太過在意哦～

```cpp=
#include "board.h"

int main(){

    ////////////////////////
    //木板
    int board_num = 0;
    scanf("%d", &board_num);

    int board[board_num];

    for (int i = 0 ; i < board_num; i++)
        scanf("%d", &board[i]);
    //
    ///////////////////////

    ///////////////////////
    //中心位址
    int n = 0;
    scanf("%d", &n);

    int *center[n], temp = 0;

    //按編號給位址
    //1. 木板不會重疊
    //2. 木板橫跨區域合法
    //3. 只有center所指向的木板才有意義
    //4. center順序有可能"不按順序"
    
    for (int i = 0 ; i < n ; i++)
    {
        scanf("%d", &temp);
        center[i] = &board[temp];
    }
    //原：int *center[] = {&(board[8]), &(board[3]), &(board[14])};
    //
    //////////////////////

    printf("%d\n", needed(center, n));

    return 0;
}
```

* 測資讀入格式：
* 1. 木板數量 (`board_num`)
* 2. board_num 個元素，代表每個 `board` 的值
* 3. center數量 (`n`)
* 4. n個元素，數值表示要給的位址為 board的編號第幾個 => (`center[i] = &board[編號]`)

---

### 如何在 命令提示字元 or 終端機 執行?
```
gcc main.c [student_ID]_q04.c -o main
./main < [測資編號].in
```

請在<font color="red"><b>相同</b></font>目錄下執行(程式所在位置)

* 上面的 `gcc`，能夠將 `main.c` 與同學檔案編譯成一個叫做 `main` 的可執行檔
* 第二行則是使用 "相對路徑" 開啟 `main`，導入 `.in`的測資，接著就會直接顯示結果
* cmd 應該可以使用 `cat [測資編號].out` 去抓檔案內容 (終端機下可以)
* cmd 檔案路徑寫法為`\`；終端機路徑寫法為 `/`


---

## 參考解答——1
> 使用 `template.c` 修改&註解的檔案應如以下面貌
> [name=育辰]

```cpp=
#include "board.h"
//繳交時，請取消註解上面這行，讓他能include .h檔
#include <stdio.h>
#include <stdlib.h>

////////////////////////////////////////////
//board.h
//函式定義的原型，繳交時請註解掉該區塊再上繳
//
//int needed(int *center[], int n);
// center: each element points to an element of "board"
// n: number of elements in "center"
//
///////////////////////////////////////////


////////////////////////////////////////////
//board.c   [同學學號_q04.c]
//同學需實作的內容
//
#include "board.h"

int needed(int *center[], int n){

    ////////////////////////
    //<--排序-->
    //依照"位址大小"作排序
    for (int i = 0 ; i < n ; i++){
        for (int j = i + 1 ; j < n ; j++){
            if (center[i] > center[j]){
                int *temp = center[i];
                center[i] = center[j];
                center[j] = temp;
            }
        }
    }
    //
    ////////////////////////

    //需要維修的木板數量
    int ans = 0;
    for (int i = 0 ; i < n-1; i++){
        //下一元素 左端點 vs //目前元素 右端點
        //假設沒空隙，兩者會差1，需扣回去
        ans += ((center[i+1] - *(center[i+1])) - ((center[i] + *(center[i]))) - 1);
    }

    return ans;
}
//如果需要，你可以自己再實作其他函式
//但 "needed" 這函式一定要寫
//
//
////////////////////////////////////////////



/////////////////////////////////////////
//main.c
//評測的參考內容，繳交時請註解掉該區塊再上繳
//實際評測未必以下列內容執行，board也可能不按照順序給
//
/*
int main(){

    int board[] = {0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0};
    int *center[] = {&(board[8]), &(board[3]), &(board[14])};
    printf("%d\n", needed(center, 3));

    return 0;
} 
*/
//
/////////////////////////////////////////
```


## 參考解答——2
> [name=王老師]

```cpp=
#include "board.h"

void bsort(int *a[], int n)
{ 
  for (int i = 0; i < n-1; i++)
    for (int j = 0; j < n-1-i; j++) 
      if (a[j] > a[j+1]) {
        int *tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
      }
  return;
}


int needed(int *center[], int n)
{
  int *l[n], *r[n];
  for (int i = 0; i < n; i++) {
    l[i] = center[i] - *center[i];
    r[i] = center[i] + *center[i];
  }
  bsort(l, n); 
  bsort(r, n); 
  int ans = 0;
  for (int i = 1; i < n; i++) 
    ans += (l[i] - r[i-1])-1;
  return ans;
}
```

### 思考方式
* #### 可參考上課講解的[影片片段](https://youtu.be/___ExsU3vfk?t=6232)
* 兩種方法思考方式都不會太過困難，請注意根據題目敘述提到：
    1. 木板==不重疊==
    2. 都是合理範圍，不會超出
    3. <font color="red"><b>只有</b></font> *center* 指向的位址其數值才有意義 (換句話說，沒指向的位址，其數字多麽沒意義都可以)
    
![](https://i.imgur.com/DiWRMVO.png)
* 如圖，如果要計算有==幾個==紅色部分，只需得到前方藍色部分的右端點index，以及後方藍色部分的左端點index，後減即可 (還要再減一)
* 但，目前測資輸入 ==不==保證按照順序輸入，你必須按照位址大小排序後，才能得到正確的前與後藍色center。(否則你可能得到第一部分、第三部分，此時按照上述方法取得數值會得到 `6`，但這數字已經不小心把中間那塊藍色給算進去了)
* 王老師的方法再開兩個存指標的陣列，分別存 **左、右端點位址**，再直接減即可
* 助教的方法是直接按照原本的 `center` 計算，會稍微直覺些
* 還有一種方法是紀錄最大、最小位址，再宣告相對應的陣列，該陣列直接==模擬塗色==，最終計算有幾個位置沒塗色就是答案了。




---

## 成績狀況

* 平均：**44.9分** ／ 標準差：**42.8**
![](https://i.imgur.com/MF0cCyw.png)



1. 檔案命名 `.c.c`，或 `. c` 本次不扣分，期末考若有相同狀況按規則<font color="red">扣分</font>
2. 回傳值從頭到尾沒計算直接輸出 `0` 不給分，程式必須經過正確的計算後回傳始得計分


### 常見錯誤
1. 沒有引入必要的標頭檔 `#include "board.h"`，或使用 abs卻沒引入 `stdlib.h`
2. 非法存取位置 (指標位址使用錯誤)
3. 常見的語法錯誤(但能編譯成功)，導致位址計算錯誤，判斷時造成無限迴圈
4. 測資餵進去後程式無法終止
5. 忘記 **sort** 或 sort 撰寫錯誤

    
## 測資

* [測資載點](https://drive.google.com/file/d/1s8RSpSbK8iBv82S0Th-4flo0I6mFXuCL/view?usp=sharing)
    > 上課有教 `cmd` 命令提示字元的檔案導入、導出，請參見 [上課影片](https://youtu.be/XphHrxBDgbU?t=430)\
    > 若無法開啟，請將`.in`, `.out`副檔名改為`.txt`就可以觀看使用，`command line`環境操作會更簡單，若有這需求的可以來信詢問助教！
* 一共`20`筆測資，採==單筆測資計分==，因此每通過一筆得`5`分，分為幾組類型的測資：

|    | Limits   |佔分|
|:---|:---------|-----:|
| #0 |只有 `center` 指向的木板有數值，且 `center` 按順序| $25$ |
| #1 |`center` 按順序| $25$ |
| #2 |只有 `center` 指向的木板有數值| $25$ |
| #3 |無特殊限制| $25$ |
| **Total** |  | $100$ |

---

### 範例測資： Input-Ex-1

```
17
0 0 0 1 0 0 0 0 2 0 0 0 0 0 1 0 0
3
3 8 14
```

### 範例測資： Output-Ex-1

```
3
```

---

# 評測測資

## 第一類型
> 只有 `center` 指向的值 有值，且 `center` 按順序

### Input: 0-0

```
10
0 0 1 0 0 1 0 0 0 0
2
2 5
```

### Output: 0-0

```
0
```

### Input: 0-1

```
10
0 0 2 0 0 0 0 0 0 0
2
2 9
```

### Output: 0-1

```
4
```

### Input: 0-2

```
15
0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
13
0 2 4 5 6 7 8 9 10 11 12 13 14
```


### Output: 0-2

```
0
```


### Input: 0-3
```
36
0 0 2 0 0 0 0 1 0 0 0 0 3 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 1 0 0 0 0 1 0 0
7
2 7 12 21 28 33 35
```

### Output: 0-3

```
5
```

### Input: 0-4
```
1
0
1
0
```

### Output: 0-4

```
0
```


---


## 第二類型
> `center` 按順序

### Input: 1-0

```
10
0 3 1 9 2 1 7 8 9 10
2
2 5
```


### Output: 1-0

```
0
```


### Input: 1-1
```
10
-1 100 2 0 0 0 250 0 500 0
2
2 9
```

### Output: 1-1
```
4
```

### Input: 1-2
```
16
-1000000 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
13
2 4 5 6 7 8 9 10 11 12 13 14 15
```

### Output: 1-2
```
0
```


### Input: 1-3
```
36
12345678 0 2 1 123123 0 -1 1 0 0 0 -3 3 0 0 0 0 0 0 32124 0 4 0 0 0 0 0 0 1 0 231 0 0 1 -8 0
7
2 7 12 21 28 33 35
```


### Output: 1-3
```
5
```


### Input: 1-4
```
1
-12345678
0
```

### Output: 1-4

```
0
```




---

## 第三類型
> 只有 `center` 指向的木板有數值

### Input: 2-0
```
17
0 1 0 0 0 0 0 0 2 0 0 0 0 0 1 0 0
4
8 3 1 14
```

### Output: 2-0
```
4
```


### Input: 2-1
```
10
0 0 2 0 0 0 1 0 0 0
3
2 9 6
```

### Output: 2-1
```
1
```


### Input: 2-2
```
15
0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
13
8 9 0 2 4 14 6 11 13 7 12 5 10
```

### Output: 2-2
```
0
```


### Input: 2-3
```
36
0 0 2 0 0 0 0 1 0 0 0 0 3 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 1 0 0 0 0 1 0 0
7
21 2 35 28 12 7 33
```

### Output: 2-3
```
5
```


### Input: 2-4
```
6
0 0 1 0 0 0
3
5 0 2
```

### Output: 2-4
```
1
```


---

## 第四類型
> 無特殊限制

### Input: 3-0
```
17
2 1 1 0 3 2 1 1 2 1 2 3 3 2 1 1 1
4
8 3 1 14
```

### Output: 3-0
```
4
```


### Input: 3-1
```
10
2147483647 6 2 5 4 3 1 2 1 0
3
2 9 6
```

### Output: 3-1
```
1
```


### Input: 3-2
```
80
0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65
13
8 9 0 2 4 14 6 11 13 7 12 5 10
```

### Output: 3-2
```
0
```


### Input: 3-3
```
37
1 1 2 1 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 4 1 1 1 1 1 1 1 1 1 1 1 1 1 0 -1
7
21 2 35 28 12 7 33
```

### Output: 3-3

```
5
```


### Input: 3-4
```
10
4 4 0 4 4 4 4 3 4 4
2
2 7
```

### Output: 3-4
```
1
```