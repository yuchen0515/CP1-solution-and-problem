# Homework 2——解答
 
||題目|出題者|
|:--|:--|:--|
|1|大小姐的生日禮物|莊博傑|
|2|桌遊部的各位|陳映達|
|3|謎底揭曉|林育辰|
|4|Surface Area and Volume of a Box|Judge Girl|
|5|Chicken, Rabbit, and Crab in a Cage|Judge Girl|

## 大小姐的生日禮物
> [name=博傑]

### 敘述

最近又快到了大小姐的生日了，學生會的其他三人決定要一起集資，派出與大小姐相識已久的書記去買禮物替大小姐慶祝，不過就在禮物買回來後，禮物的價格卻與本來的預算差了 $n$ 元，所以需要退錢或是再跟大家收錢。  
不過要計算這麼複雜的數學對於 IQ 只有 3 的書記來說實在是太困難了，請你寫個程式來幫書記計算，每個人需要再付或是可以拿回多少錢，以及最後剩下的金額。

### 測資說明

#### Input

輸入僅一個整數 $n$，代表的是與本來預算的差距金額。  
其中 $-100 \le n \le 100$

#### Output

請輸出兩個數字 $q, r$  
$q$ 表示大家需要付出或是可以拿回多少錢  
$r$ 表示最後會多出多少錢

### Example Input 0

```
7
```

### Example Output 0

```
2 1
```

### Example Input 1

```
-5
```

### Example Output 1

```
-2 1
```

### Hint

- 以第一筆範例測資 $n=7$ 來說，因為剩下了七塊錢，每人可以拿回兩元，最後會剩下一元充公，因此要輸出 `2 1`。
- 第二筆範例測資 $n=-5$ 代表不夠五塊錢，所以每人要再付兩元，並且最後會多出一元充公，因此要輸出 `-2 1`。


### 參考程式
> [name=映達]

```cpp=
#include <stdio.h>

int main() {
    const int d = 3;

    int n = 0;
    scanf("%d", &n);
    
    int r = (n % d + d) % d;
    int q = (n - r) / d;
    printf("%d %d", q, r);
}
```

- 此題重點在於發覺 C 語言模數（`%`）的特性：

對於
$$
a \div b = q\,_\cdots\,r
$$
其中 $q = \frac{a}{b}$ 會「向 0 取整」(捨棄小數點):
$$
\begin{align}
\frac{5}{3} &= 1.667 &&\Rightarrow 1 \\
\frac{-5}{3} &= -1.667 &&\Rightarrow -1
\end{align}
$$
且永遠滿足
$$
\begin{align}
a &= b \times q + r \\
\Rightarrow r &= a - b \times q
\end{align}
$$
因此當 $a$ 為負數時，$r$ 的結果亦會為負數，在本題需要特別的處理。

一些已經學過 `if` 的同學大概會想到可以用 `if` 判斷 $a$ 的正負號；對於跟著老師進度的同學，也有其他的方法：

```cpp=9
    int r = (n % d + d) % d;
```

其中本題 `d = 3` 。以上可以分成兩步驟理解：

- 第一次做 `n % 3` 結果的可能是 $-2,\,-1,\,0,\,1,\,2$ 其中之一。
- 第二次做 `% 3` 前，先加 $3$ 即可保證結果為正數。

最後再用餘數反推商數：

```cpp=10
    int q = (n - r) / d;
```

---

## 桌遊部的各位
> [name=映達]

### Description

槙前辈、書記、Giga 子三人皆是桌遊部的成員，平時最喜歡玩各式各樣的桌遊，甚至將整個校園當做遊戲的地圖。今天，不，不只今天，每當她們玩桌遊前，經常需要先煩惱一件事：誰可以先手？

該桌遊部自古流傳著一句話：「千花的千，是老千的千」。猜拳，雖然只能算是桌遊開始前的準備，可以決定玩家的先後順序。但其本質仍然是一種遊戲；既然是遊戲，當然會有人為了勝負不擇手段、甚至作弊！

為了公平起見，請你寫一支程式，來幫助桌遊部的各位判定猜拳的勝負吧！

### Input

有三個整數，$x_0$、$x_1$、$x_2$ 依序代表槙前辈、書記、Giga 子的選擇。數字對應的意義為：

0. 剪刀
1. 石頭
2. 布

### Output

若結果出現**唯一**一位贏家，則輸出該玩家編號：

0. 槙前辈
1. 書記
2. Giga 子
 
否則輸出 $-1$。

（這是當然的，因為我們要選出先手的那**一位**玩家。若有兩位贏家出現，相當於尚未得到結果。）

### Example Input 0

```
0 2 2
```

### Example Output 0

```
0
```

### Example Input 1

```
0 0 2
```

### Example Output 1

```
-1
```

### Hint

1. 善用餘數找規律
2. 拿出紙筆算算看

對於所有輸入，$x_0, x_1, x_2 \in \{0, 1, 2\}$。

#### Subtask 1: 95%

輸入保證出現恰好一位贏家。

#### Subtask 2: 5%

無其他限制。

### 參考程式
> [name=映達]

#### Solution 1 (95 %)

```cpp=
#include  <stdio.h>

int main() {
    int p0 = 0, p1 = 0, p2 = 0;
    scanf("%d %d %d", &p0, &p1, &p2);
    
    int winner = (p1 - p2 + 3) % 3;
    printf("%d", winner);
}
```

以上方法關鍵的一行為

```cpp=7
    int winner = (y - z + 3) % 3;
```

可以分成三種狀況解讀：

- 當 `p0` 勝利時，代表 `p1` 和 `p2` 相同，因此相減為 `0`。

- 當 `p1` 勝利時，因為「剪刀 `0`、石頭 `1`、布 `2`」的順序，「贏 `p1`」減「輸 `p2`」除以 3 的餘數正好為 `1` （或 `-2`，這裡可以用上一題的方法，處理相減出現負數的情況）。

- 當 `p2` 勝利時，代表 `p1 - p2` 只可能是 `-1` 或 `2`，因此除以 3 的餘數（處理後）皆為 `2`。

#### Solution 2 (95 % + 5 %)

```cpp=
#include <stdio.h>

int main() {
	int x, y, z;
	scanf("%d %d %d", &x, &y, &z);

	int a = (x - y + 3) % 3;
	int b = (y - z + 3) % 3;
	int c = (a - b + 3) % 3 % 2;

	int winner = (b + 1)*c - 1;
	printf("%d\n", winner);
}
```

---

## 崩壞的減肥計劃
> [name=育辰]

### 敘述

$\text{Willy}$ 沈迷一款解謎遊戲，他進入到一個雪地，並用鏟子挖掘後發現一個神秘的盒子，打開後只寫著一個整數 $n$。

回到主畫面，意外發現紅色門的門把上刻了數字 $S_1$，以及天花板與牆角的縫隙也寫了一數字 $S_2$。

到了一個隱密的場景，有個沖天炮被一數字鎖鎖著，其共有 $8$ 位數，在上頭放置有 $h_1$ 小時、 $m_1$ 分鐘、$s_1$ 秒數的時鐘，下頭亦放置類似的時鐘，時間未必相同，其時、分、秒依序為 $h_2, \, m_2, \, s_2$。

因為怎麼解都解不開，於是偷偷去 $\text{Youtube}$ 看了攻略...


**攻略大秘籍**
1. $n$ 表示最大可接受的數值，若今後得到一數值 $n+1$，則從 $0$ 開始繼續計算，若數值小於 $0$ 則從 $n$ 往下倒數：
   > 例如： $n = 1000$
   > * $1001$ 則結果為 $0$，$1002$ 則結果為 $1$
   > * $-1$ 則結果為 $1000$，$-2$ 則結果為 $999$
   > * $5342$ 則結果為 $337$
   > * $-200$ 則結果為 $801$
2. 計算 $S_1 - S_2$，並以攻略第一步中的 $n$ 去計算結果 $A_1$
3. 接著計算 由上方的開始時間，到下方的結束間所經過的**秒數**，並以單位**秒**表示，結束時間不會早於開始時間，且不會到隔天。
4. 將第三步驟所得之結果加上 $A_1$，其數值再以攻略第一步之方式計算最後結果，最終數值即為密碼鎖之答案，若有空格處則補 $0$

請你按照攻略寫出一個程式幫助 $\text{Willy}$ 破關吧！！


### 測資說明

$\text{Line 1: }$ 一整數 $n$\
$\text{Line 2: }$ 兩個整數 $S_1, \, S_2$，以空格間隔\
$\text{Line 3: }$ 三個整數 $h_1, \, m_1, \, s_1$，以空格間隔\
$\text{Line 4: }$ 三個整數 $h_2, \, m_2, \, s_2$，以空格間隔

**limit**
* $1 \leq n \leq 2 \times 10^{5}, \, n \in \mathbb{N}$
* $0 \leq S_1, S_2 \leq 2^{30}, \ S_1, S_2 \in \mathbb{N}$
* $0 \leq h_1 \leq h_2 < 24, \  h_1, h_2 \in \mathbb{N}$
* $0 \leq m_1, m_2 < 60, \ m_1, m_2 \in \mathbb{N}$
* $0 \leq s_1, s_2 < 60, \ s_1, s_2 \in \mathbb{N}$
* $|\text{
Elapsed time} + (S_1 - S_2)| \leq (1000 \times n + 1000)$


**Output**\
$\text{Line 1: }$ 一整數 $A$，即密碼鎖密碼，需換行，且共八位數，不足需補零

**SubTask**
- Subtask 1: 25%\
$0 \leq \text{
Elapsed time} \ + \  (S_1 - S_2) \leq n$
- Subtask 2: 35%\
$0 \leq \text{
Elapsed time} \ + \ (S_1 - S_2)$
- Subtask 3: 40%\
無其他限制

### Sample Input

    1000
    2800 4200
    4 5 30
    23 59 59

### Sample Output

    00000199
    
### Hint

* 善用`+` `-` `*` `/` `%`運算
* **Elapsed time** (經過的秒數) 是求 **開始時間到結束時間，中間共經過幾秒**，而非最短時間差，此外第二個時間不會到隔天 (滿足 $h_1 \leq h_2 < 24$)
* 建議從餘數思考，以及測資限制為小提示 (如何善用最後一個條件？)
* `printf("%08d\n", ans);` 可以處理格式問題
* 2020.09.30補：
類似上課提及的Overflow概念，對於負數的處理，你可以充分運用**最後一個條件**，並用 `+` 去處理
* 2020.09.30補：
同學可觀察範例測資，起初 $n=1000$，之後計算$S_1-S_2 = 2800 - 4200 = -1400$，並由步驟1所述，得到 $A_1 = -1400 + 2002 = 602$，接著計算所經過的時間得到 $71669$，依照步驟四，將該數字加上 $A_1$ 得到 $72271$，代回第一步驟之條件得到 $199$

	
	
### 參考程式
> [name=育辰]

```cpp=
#include <stdio.h>
#include <stdint.h>

int main(){

    //Input
    int32_t n = 0;
    int32_t S1 = 0, S2 = 0;
    int32_t h1 = 0, m1 = 0, s1 = 0;
    int32_t h2 = 0, m2 = 0, s2 = 0;

    //Read
    scanf("%d", &n);
    scanf("%d %d", &S1, &S2);
    scanf("%d %d %d", &h1, &m1, &s1);
    scanf("%d %d %d", &h2, &m2, &s2);

    //Key concept: overflow
    int32_t ans = S1 - S2;
    ans = ans + (h2 * 3600 + m2 * 60 + s2) - (h1 * 3600 + m1 * 60 + s1);

    //Dead with "negative" situation via + 1000*(n+1) [The last limit]
    ans = (ans + 1000 * (n+1) ) % (n+1);
    printf("%08d\n", ans);

    return 0;
}
```


#### 小說明

* 此題關鍵之一在於運用 `%` 的特性去模擬 `Overflow` 的狀況
* 同學可以想像現在在一個新的整數變數型態，然其範圍區間為 $[\, 0, \, n \, ]$，接著，同王老師上課談到的 `Overflow` 概念，務必密切關注上界和下界的情形，如：
    1.  $\ n+1 = 0$
    2.  $\ n+2 = 1$
    3.  $\ n+3 = 2$
    4.  $\ 0-1 = n$
    5.  $\ 0-2 = n-1$
* 如果使用同學所學的 `int`，可以想像成當數字儲存為 $2^{31}-1$，此時若再 $+1$ 則儲存數值變成 $-2^{31}$ (ps. `overflow`)
* 我們保證了**結束時間**會晚於或等於**起始時間**，而且結束時間不會跨夜，也就是說同學無需使用判斷式去運算時間問題，單純將兩個時間換算為**秒**，相減即可
    

#### 解題思路

1. 因我們採用區間為 $[\ 0, \ n \ ]$ 的範圍，在整體系統上無論先處理、後處理結果都一樣 (解題步驟中提到 先計算 $S_1 - S_2$ 接著套用到 攻略第一步驟，但事實上先處理，或計算完時間相加再套用到第一步驟結果也是一樣的)
2. 讀取變數後，直接計算 $S_1 - S_2$，根據上述**小說明**\
    時間計算如下：
    $$=(h_2 * 3600 + m_2 * 60 + s_2) - (h_1 * 3600 + m_1 * 60 + s_1)$$
3. 將上述計算之結果 加上 $(S_1 - S_2)$
4. 如何模擬？若我將計算結果直接 mod (n+1)...
    > 
    > - $1000 \ \% \ 1001 = 1000$
    > - $1001 \ \% \ 1001 = 0$
    > - $1002 \ \% \ 1001 = 1$
    > - $1003 \ \% \ 1001 = 2$\
    > $\cdots$
5. 第四點運算模式，已處理了計算結果為 **正數** 的情況，那負數呢？
    > - $(-1 + ( \ 1001 \ ) \ ) \% \ 1001 = 1000$
    > - $(-2 + ( \ 1001 \ ) \ ) \% \ 1001 = 999$
    > - $(-3 + ( \ 1001 \ ) \ ) \% \ 1001 = 998$
6. 不過...負數若為 $-1002$，則將無法計算，這時候就有許多同學運用到迴圈，但如果仔細看題目，在hint處有寫道 **善用limit最後一個條件**，我們保證了結果的數值不會超過 $1000 \times (n+1)$，或低於 $-1000 \times (n+1)$
7. 承上，我們mod $(n+1)$，若我加上 $(n+1)$也絲毫不影響結果，因此計算後的結果直接加上 $1000 * (n+1)$，再 mod $(n+1)$ 就能得到答案
    > 關於輸出格式在 hint 有直接指出如何輸出了哦！
    > `printf("%08d\n", ans);`

**關鍵算式**

$$((A_1 + \text{Elapsed time}) + 1000 \times (n+1)) \  \% \ (n+1)$$

> **小插曲**\
> 為何限制 $1000n+1000$？其原身其實是 $1000 \times (n+1)$，為了避免同學處理負數時用到判斷式，因此加此限制

---

## Surface Area and Volume of a Box 
> [name=Judge Girl]

### Description

請寫出一個程式，給定 $a, \, b, \, c, \, d, \, e$，並參考下圖輸出其表面積和體積。

![](https://i.imgur.com/QBY8sPY.png)



### Input

* $\text{Line} \, 1 \text{~} 5$: 分別為 $a, \, b, \, c, \, d, \, e$，皆為整數


### Output

* $\text{Line} \, 1$: 表面積 $P, \ P \in \mathbb{P}$
* $\text{Line} \, 2$: 體積 $V, \ V \in \mathbb{N}$ 


### Example Input

    6
    8
    10
    1
    2
   


### Example Output

    472
    392


### Hint
* 中間為**實心**，六面向**內凹**

> from `Judge Girl`

### 參考程式
> [name=育辰]

```cpp=
#include <stdio.h>  
#include <stdint.h>  
  
int main(){  
    int32_t a = 0 , b = 0 , c = 0 , d = 0, e = 0;  
    int32_t surface = 0 , volume = 0;  
  
    scanf("%d %d %d %d %d", &a, &b, &c, &d, &e);  
  
    surface = 2*(a*c + b*c + a*b) + 8*(a*d + b*d + c*d) - 48 * d * e;  
    volume = a*b*c\
             -2*d * (a-2*e) * (c-2*e)\
             -2*d * (b-2*e) * (c-2*e)\
             -2*d * (a-2*e) * (b-2*e);  
  
    printf("%d\n%d\n", surface, volume);  
  
  
    return 0;  
}

```

* 關鍵在於 一個長方體，六面皆凹陷進去，但最內為 **實心**，此外 `e` `d` 六面寬度、凹陷深度都一樣，因此直接計算表面積、體積即可

---


## Chicken, Rabbit, and Crab in a Cage 
> [name=Judge Girl]

### Description
有雞、兔子和螃蟹在同一個籠子裡，先不論其是否會打架，是否會履行其生態鏈的角色，我們先假設他們暫時忘卻本能，直到你的程式運行完畢，輸出正確結果後，不用再管他們的生或死...

承上，現給定這些動物的總數($s$)、動物腳的總數($f$)以及動物尾巴的總數($t$)，請依序輸出雞、兔子、螃蟹的數量。

* **給定的數字保證有解**


### Input
* $\text{Line} \, 1$: 三個整數以空格分隔，依序為 $s, \,  f, \, t$

#### Limit
* $0 \leq s, \, f, \, t \leq 2^{31} -1$


### Output
* $\text{Line} \, 1$: 一整數 $A_{1}$ 表示**雞**的數量
* $\text{Line} \, 2$: 一整數 $A_{2}$ 表示**兔子**的數量
* $\text{Line} \, 3$: 一整數 $A_{3}$ 表示**螃蟹**的數量

### Example Input

    9 48 5


### Example Output

    2
    3
    4


### Hint

* 在本題中，雞預設為2隻腳, 1尾巴，兔子為4隻腳, 1尾巴，螃蟹為8隻腳（不算螯足)


> from `Judge Girl`
### 參考程式
```cpp=
#include <stdio.h>  
#include <stdint.h>  
  
int main(){  
    int32_t chicken = 0, rabbit = 0, crab = 0;  
    int32_t s = 0 , f = 0 , t = 0;  
      
    scanf("%d %d %d", &s, &f, &t);  
  
    crab = s - t;  
    rabbit = (f - 2*s - 6 * crab)/2;  
    chicken = t - rabbit;  
  
    printf("%d\n%d\n%d\n", chicken, rabbit, crab);  
  
    return 0;  
}  
```

* 關鍵在於列式，解方程式即可：\
\
$\begin{cases}
s = chicken + rabbit + crab\\
f = 2 \times chicken + 4 \times rabbit + 8 \times crab\\
t = chicken + rabbit\\
\end{cases}$

* $\begin{cases}
 crab = s-t \\
 2 \times rabbit + 6 \times crab = f- 2 \times s\\
 rabbit = t - chicken\\
\end{cases}$

> 未必和程式的運算步驟相同，方程式有很多種解法 (不過題目保證了有唯一解！)

