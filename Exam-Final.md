# 期末考批改、評分標準暨參考解答

|題號             |批改者    |分數|
|:--             |:--      |:--|
|$1, 2, 3, 4$    |陳映達    |$28$|
|$5, 6$          |林育辰	 |$42$|
|$7$             |莊博傑	 |$30$|
|**Total**       |   	   |$100$|


## 期末考分佈圖

![](https://i.imgur.com/ODQ8IAI.png)


* 平均：$46.75$ 分
* 標準差： $22.06$


## 觀念題

|題號|分數|評分準則|
|:--|:--|:--|
|1|$7$ %|- 可以正確完成題要求|
||$4$ %|- 說明了 array 可以想成連續的空間，<br>&nbsp;&thinsp; 要先計算原本的位置再換算；但<br>&nbsp;&thinsp; 未正確寫出算式。|
|2|$7$ %|- 緩衝區覆蓋|
||$4$ %|- 只提到輸入超過範圍，<br>&nbsp;&thinsp; 未提到或正確解釋緩衝區覆蓋相關概念|
|3|$7$ %|- 以值傳遞|
|4|$7$ %|- C 的 floating point literal 預設是 double，<br>&nbsp;&thinsp; 判斷式應改為 0.1f 或將 a 改為 double。<br>&nbsp;&thinsp; >&nbsp; [Ref](https://en.cppreference.com/w/cpp/language/floating_literal)<br>- 浮點數有誤差（0.1 無法以二進位表示）|

---

### 1. (7 points) 考慮下列程式碼：

```cpp=
void process_array(int b[3][4], int x, int y)
{
    b[x][y] = 1;  // modify x & y 
    return;
}

int main()
{
    int a[4][3] = {};
    process_array(a, 1, 0);
    return 0;
}
```

此程式順利執行結束後，a[1][0] 仍為 0。請修改程式碼中註解那行的 x 與 y，使得對於任何 i 與 j (0 ≤ i < 4, 0 ≤ j < 3)，process_array(a, i, j) 皆能正確的修改 a[i][j] 的值。 


#### 參考解答
- p1. (式子表示正確就行)
    - x -> (3*x + y) / 4
    - y -> (3*x + y) % 4 
   





---

### 2. (7 points) 考慮下列程式碼：


```cpp=
#include <stdio.h>

int main()
{
    char mystring[2][4];
    scanf("%s", mystring[1]);
    printf("%s", mystring[1]);
 
    scanf("%s", mystring[0]);
    printf(" %s\n", mystring[1]);
 
    return 0;
}
```

輸入
    
```
abc defg
```
    
輸出

```
abc
```
    
在讀入 mystring[0] 後再輸出 mystring[1] 則非 abc，這個狀況稱之為何？


#### 參考解答
- p2. (以下皆可)
    - buffer overrun (緩衝區覆蓋)
    - buffer overflow (緩衝區溢位)





---


### 3. (7 points) C 語言的函式參數傳遞機制為何？



#### 參考解答
- p3. (以下皆可) 
    - pass by value
    - call by value


---


### 4. (7 points) 考慮下列程式碼：
```cpp=
#include <stdio.h>

int main()
{
    float a;
    scanf("%f", &a);
    
    if (a == 0.1) 
        printf("a = 0.1\n");
    else
        printf("a != 0.1\n");
   
    return 0;
}
```

當輸入 0.1 時，輸出為「a != 0.1」，請問原因為何？



#### 參考解答

- p4. (以下皆可)
    - 以二進制表示浮點數為無窮位數的小數，但計算機中僅能以有限位數儲存數值，故會產生精確度的差異。
    - C 的 floating point literal 預設是 double，判斷式應改為 0.1f 或將 a 改為 double。[[ref](https://en.cppreference.com/w/cpp/language/floating_literal)]
    - 浮點數有誤差（0.1 無法以二進位表示）


---

## 實作題

### 5. (20 points ) 給定平面上兩點 A 與 B，請求直線 AB 的斜率。

#### Input Format
四個整數 $x_1, y_1, x_2, y_2$，介於 $-1000$ 至 $1000$ 之間 (包含二邊界)，其中 $(x_1, y_1)$ 與 $(x_2, y_2)$ 分別代表點 $A$ 與 點 $B$ 的座標。測資保證 $x_1 \neq x_2$


#### Output Format
一浮點數，為所求斜率四捨五入至小數點下第二位。




#### Sample Input 1
```
-1 -1 2 4
```

#### Sample Output 1
```
1.67
```



#### Sample Input 2
```
0 0 3 1
```

#### Sample Output 2

```
0.33
```

---

### 參考解答
> [name=育辰]

```cpp=
#include <stdio.h>

int main(){

    int x1 = 0, y1 = 0;
    int x2 = 0, y2 = 0;

    scanf("%d %d %d %d", &x1, &y1, &x2, &y2);

    double ans =\
                (((double)y2) - y1) / (((double)x2) - x1);

    printf("%.2lf\n", ans);

    return 0;
}
```

* 本題因需處理四捨五入，直接簡單利用 `%.2lf` 程式便會處理了，例如範例測資 `-1 -1 2 4`，若無四捨五入，則輸出為 `1.66`，有四捨五入則輸出為 `1.67`
* 承上，因負數斜率四捨五入容易遇到問題，因此本題測資**不會**有負數的斜率
* 參考解答之程式碼，`((double)y2) - y1` 的寫法，由於這邊運算是 `double` 的 y2 遇上 `int` 的 y1，型態範圍上前者較大，因此後者的 `int` 會轉為 `double` 與 y2 作運算，後面的 `((double)x2)-x1`也是一樣的道理，當 `double/double`時，就照常計算，最終簡單輸出 `%.2lf` 即可。
* 若同學不是用 `double` 而是 `float`，答案應會一致。


---

### 評分
> [name=育辰]

本題評測共有 25 筆測資，其中 15 筆為助教人工產生，10 筆為亂數產生，測資不會包含 斜率為負 的情況。
 * [測資載點](https://drive.google.com/file/d/1TTvwr9OEGHmU_iAJc0N4gWUXxV029JsP/view?usp=sharing)
 * [助教批改腳本](https://drive.google.com/file/d/1gwA2P5zx-GC7A85eFwLEzpcT9u6pi-hq/view?usp=sharing)

---


#### Input Set 1
* <p>0000.in ~ 0004.in</p>
> 不需四捨五入的測資，因本題測資相對單純，故一區直接騰列五筆測資。

```
2 2 4 3
-1000 0 1000 0
-237 1000 90 1000
1 15 11 165
165 12 55 1
```

#### Output Set 1

```
0.50
0.00
0.00
15.00
0.10
```


---


#### Input Set 2
* <p>0100.in ~ 0104.in</p>
> 需四捨五入的測資

```
-15 -15 30 60
0 0 480 160
-1000 570 1000 581
1000 0 -1000 -9
-999 1000 -1000 -1000
```

#### Output Set 2

```
1.67
0.33
0.01
0.00
2000.00
```

---


#### Input Set 3
* <p>0200.in ~ 0204.in</p>
> 需四捨五入的測資 (特殊數字)

```
171 620 211 842
573 573 -427 24
-427 29 573 573
8 6 2 -5
923 0 423 -665
```

#### Output Set 3

```
5.55
0.55
0.54
1.83
1.33
```

---



#### Input Set 4
* <p>0300.in ~ 0304.in</p>
> 亂數的測資 (保證斜率為正、 $x_1 \neq x_2$)

```
186 620 -879 -656
814 865 -725 527
-597 -897 941 -751
-765 -210 -625 -146
849 642 -127 -477
```

#### Output Set 4

```
1.20
0.22
0.09
0.46
1.15
```


---


#### Input Set 5
* <p>0400.in ~ 0404.in</p>
> 亂數的測資 (保證斜率為正、 $x_1 \neq x_2$)

```
-42 -100 26 393
-44 -651 39 939
-24 397 -43 -436
8 582 -37 -378
-10 896 -45 -767
```

#### Output Set 5

```
7.25
19.16
43.84
21.33
47.51
```





---

### 6. (22 points 下三角龍捲風) 
給定一 $N\times N$ 的二維陣列 $A$，我們可由元素 `A[0][0]` 開始，以**順時針**旋轉的方式走訪陣列 $A$ ==對角線以下== 的每個元素恰好一次。對於給定的陣列，請依上述的走訪順序，當遇到「**大於等於**」週遭 (上、下、左、右) 的元素時，則輸出該元素。注意，每個元素的「週遭」若不在陣列定義的範圍內，則忽略不計；例如若 $A$ 為 $3\times 3$ 的陣列，則 `A[0][0]` 的週遭僅有 `A[0][1]` 及 `A[1][0]`。\
\
以 $N = 4$ 為例，下圖左的陣列其下三角的元素走訪順序由左上角開始依箭頭前進，輸出的數字為 `589`。類似地，下面的 $(5\times 5)$ 陣列輸出為 `548348`。 

![](https://i.imgur.com/2Kn6Iyy.png)

#### 輸入說明
輸入的第一行有一個正整數 (不超過 $100$)，表示 $N$；接下來的 $N$ 行，每行有 $N$ 個數字 (若此 $N$ 行由上而下編號為 $0$ ~ $(N-1)$，第 $i$ 行的 $N$ 個數字表示陣列元素 `A[i][0]` ~ `A[i][N-1]`；每個數字為一 $0$ ~ $100$ 的整數，同一行的數字以一空白間隔。

#### 輸出說明
輸出為一連串的數字，中間不要有空白，結尾為一==換行==字元。




#### Sample Input 1
```
4
5 3 4 4
3 1 8 6
9 0 5 3
2 3 6 8
```

#### Sample Output 1

```
589
```


#### Sample Input 2

```
5
5 3 4 4 7
1 4 2 9 1
3 1 8 8 4
4 0 8 3 10
2 3 1 8 9
```

#### Sample Output 2

```
548348
```


#### Sample Input 3

```
3
6 2 8
2 1 0
1 8 4
```


#### Sample Output 3
```
68
```

#### Sample Input 4

```
4
6 2 9 8
2 1 7 0
1 8 3 4
7 2 5 1
```

#### Sample Output 4

```
6578
```

---

### 參考解答
> [name=育辰]

```cpp=
#include <stdio.h>
#include <stdbool.h>

int main(){ 

    int n = 0;
    scanf("%d", &n);

    //宣吿 n+2 是為了讓邊界更好處理
    int arr[n+2][n+2];

    //讀取
    for (int i = 0 ; i <= n+1 ; i++){
        for (int j = 0; j <= n+1 ; j++){
            //如果該欄是邊界就設為 1000
            arr[i][j] = 1000;

            if (i >= 1 && i <= n && j >= 1 && j <= n)
                scanf("%d", &arr[i][j]);

        }
    }
    
    //下三角包含邊界的總數相當於 從 1 加到 n
    int total = (n * (n+1)) / 2;

    //往右下、往左、往上 三個不同方向為三角形尋訪方向
    int dir[3][2] =
    {
        {1, 1},
        {0, -1},
        {-1, 0}
    };

    //上下左右的方向，負責檢查周遭數字情況
    int check_dir[4][2]=
    {
        {1, 0},
        {0, 1},
        {-1, 0},
        {0, -1}
    };


    //目前位置、方向
    int cur_x = 1, cur_y = 1;
    int cur_dir = 0;

    while (total--){
        //先假設大於等於周遭數字
        bool geq_print = 1;
        
        //檢查上下左右，途中遇到不符合的就將 geq_print設為0
        for (int i = 0 ; i < 4 ; i++){
            if (arr[cur_x][cur_y] < arr[cur_x + check_dir[i][0]][cur_y + check_dir[i][1]] % 1000){
                geq_print = 0;
                break;
            }
        }
        
        //如果 geq_print還等於1，表示符合條件可以印出
        if (geq_print)
            printf("%d", arr[cur_x][cur_y]);

        //走過的元素 以 加 1000作為記號
        //因輸入測資範圍只介於 0~100
        arr[cur_x][cur_y] += 1000;

        //如果下一個位置走過，表示需要順時針換方向
        if (arr[cur_x + dir[cur_dir][0]][cur_y + dir[cur_dir][1]] >= 1000)
            cur_dir = (cur_dir + 1) % 3;

        //走到下一個位置
        cur_x += dir[cur_dir][0];
        cur_y += dir[cur_dir][1];
    }

    //最後記得換行
    printf("\n");

    return 0;
}
```


---

### 評分
> * [測資載點](https://drive.google.com/file/d/19DgjF0j4UWReCpGqmJr5SKBvl4GoPT4m/view?usp=sharing)
> * [助教批改腳本(參考用)](https://drive.google.com/file/d/1Kmrx_jw-vfYGzNQcHP3G8e0PysBsj4QP/view?usp=sharing)
> [name=育辰]


* 一共 `44` 筆測資，採==單筆測資計分==，因此每通過一筆得 `0.5` 分，分為七種類型的測資：
    1. $N \leq 5$
    2. $N \leq 25$
    3. $N \leq 50$
    4. $N \leq 100$
    5. $N = 50$，亂數產生
    6. $N = 100$，亂數產生
    7. $N \leq 100$，亂數產生
* 在各個類型中會包含：
    1. $N$ 為奇數、偶數
    2. $N$ 「大於等於」、「大於」
    3. 邊界印值，中間幾乎不印 或反過來
* N有可能為 $1$ 或 $100$
 
---


#### Input-0000
* $N \leq 5$

```
3
6 2 8
6 1 8
3 4 4
```

#### Output-0000

```
646
```


#### Input-0001
* $N \leq 5$

```
1
100
```

#### Output-0001

```
100
```

#### Input-0002
* $N \leq 5$

```
2
59 60
57 59
```

#### Output-0002
* 僅輸出一換行字元

```

```

#### Input-0003
* $N \leq 5$

```
4
7 5 1 2
60 100 8 2
1 33 4 8
2 7 0 1
```

#### Output-0003

```
100
```

#### Input-0004
* $N \leq 5$

```
5
1 2 1 2 1
2 3 5 3 2
1 4 6 40 1
2 5 7 1 2
1 2 1 2 1
```

#### Output-0004

```
27
```

#### Input-0005
* $N \leq 5$

```
4
51 3 42 42
31 1 82 64
91 0 52 38
21 37 62 89
```

#### Output-0005

```
518991
```

#### Input-0006
* $N \leq 5$

```
5
5 3 4 4 7
1 4 2 9 1
3 1 8 8 4
3 8 8 8 4
4 0 8 3 100
2 3 1 8 9
```

#### Output-0006

```
548810084388
```


#### Input-0007
* $N \leq 5$

```
3
67 10 18
9 1 0
1 81 4
```

#### Output-0007

```
6781
```


#### Input-0008
* $N \leq 5$

```
4
67 2 9 28
20 1 7 10
1 8 3 4
7 2 5 1
```

#### Output-0008

```
67578
```


---

#### Input-0100
* $N \leq 25$

```
10
1 2 3 4 5 6 7 8 9 0
9 8 7 6 5 4 3 2 1 0
33 4 5 6 7 8 9 0 1 2
5 4 3 2 1 0 9 8 7 6
0 100 0 0 0 0 0 0 0 0
11 11 11 11 11 11 11 11 11 11
1 11 1 1 9 15 6 2 1 0
9 9 9 9 9 15 9 2 1 1
3 22 2 1 4 15 4 5 2 52
9 8 7 6 5 15 5 6 3 71
```

#### Output-0100

```
71615991133111515221110011159911
```


#### Input-0001
* $N \leq 25$

```
6
9 8 7 8 9 8
1 1 2 1 4 7
7 3 6 2 1 8
8 71 6 2 1 7
9 8 7 6 5 9
0 9 8 7 8 9
```

#### Output-0101

```
9699971
```

#### Input-0102
* $N \leq 25$

```
25
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 90 80 70 60 50 40 30 20 10
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 40 50 40 30 20 10
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 50 40 30 20 10 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 50 40 30 20 10 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0 0 40 30 20 10 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 40 30 20 10 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 30 20 10 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 30 20 10 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 30 20 10 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 30 20 10 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 10 
0 0 0 0 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 10 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 10 
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 10 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 10 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 10 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 10 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20 10 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 20 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
```

#### Output-0102

```
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000010000000000000000000000001000000000000000000000000000
```

#### Input-0103
* $N \leq 25$

```
14
1 2 1 2 1 2 3 4 3 4 3 4 1 2
2 2 9 9 9 9 9 9 9 9 9 9 9 2
1 3 1 8 8 8 8 8 8 8 8 8 9 1
2 6 3 2 7 7 7 7 7 7 7 8 9 2
1 5 6 3 1 6 6 6 6 6 7 8 9 3
3 6 8 7 3 2 5 5 5 6 7 8 9 5
4 5 8 7 8 3 1 4 5 6 7 8 9 6
3 6 8 7 6 7 3 2 5 6 7 8 9 6
2 5 8 7 6 5 7 3 1 6 7 8 9 2
1 5 8 7 6 6 6 8 3 2 7 8 9 1
2 5 8 7 7 7 7 7 7 3 1 8 9 3
3 5 8 8 8 8 8 8 8 8 4 2 9 4
4 4 4 4 4 4 4 4 4 4 3 3 1 1
3 1 2 1 2 1 2 1 2 1 2 1 2 2
```

#### Output-0103

```
224236877888888888888888
```

#### Input-0104
* $N \leq 25$

```
21
4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 9
1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1
9 2 3 3 3 3 3 3 3 3 3 3 3 3 9 3 3 3 3 2 1
1 2 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 2 1
1 2 33 2 5 5 5 5 5 5 5 5 5 5 5 5 5 4 3 2 1
1 2 3 4 5 6 6 6 6 6 6 6 6 6 6 6 5 4 3 2 1
1 2 3 4 5 6 7 7 7 7 7 7 7 7 7 6 5 4 3 2 1
1 2 3 4 5 8 7 8 8 8 8 8 8 8 9 6 5 4 3 2 1
1 2 3 4 5 6 1 8 9 9 9 9 9 8 7 6 5 4 3 2 1
1 2 3 4 5 6 7 3 1 9 3 9 3 8 7 6 5 4 3 2 1
1 2 3 1 5 6 1 8 9 1 9 5 9 8 7 6 5 4 3 2 1
1 3 3 4 5 6 7 8 9 2 9 9 9 8 8 6 5 4 3 2 1
1 27 3 4 5 6 7 8 3 9 8 9 8 8 7 6 5 4 3 2 1
1 2 3 4 5 6 7 9 8 8 8 8 8 9 7 6 5 4 3 2 1
1 2 3 4 5 6 7 7 7 7 7 7 7 7 7 6 5 4 3 2 1
1 2 3 4 5 6 6 6 6 6 6 6 6 6 6 6 5 4 3 2 1
1 2 9 4 5 5 5 5 5 5 5 5 5 5 5 5 5 4 3 2 1
1 2 3 4 6 4 4 4 4 4 4 4 4 4 4 4 4 4 3 2 1
1 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 1
1 2 22 2 2 2 2 2 2 2 2 2 8 2 2 2 2 2 2 2 1
2 1 1 1 1 1 1 1 1 1 10 1 1 1 1 1 1 1 1 1 9
```

#### Output-0104

```
4234567899999765432910299982227338993799866697
```




* ### 其餘測資較大，不在此騰列，請下載 [.zip](https://drive.google.com/file/d/19DgjF0j4UWReCpGqmJr5SKBvl4GoPT4m/view?usp=sharing) 檔

---

### 7. (30 points 矩陣排序) 

給一指標陣列 P，每個指標指向一整數二維陣列中的一個元素。你知道該陣列的維度 (列數與行數)，以及該元素在陣列中的註標。現有想要將指標陣列排序，二元素兩元素 a 與 b 的順序判斷，即為 a 位於的行向量與b位於的行向量之字典序比較結果。以下圖為例，P[0] 指向 A[1][1]，P[1] 指向 B[0][1]，兩元素所在的行向量分別為 (2, 4) 與 (2, 1, 4)，前者字典序大於後者，故 P[0] > P[1]。


![](https://i.imgur.com/x9PSYDU.png)


請實作下列函式： 
* 注意：實作函式檔，務必引入需要的標頭檔，程式內勿包含 main function，測試後應記得註解掉，否則依檔案格式錯誤處置。

```cpp
void sort_p(int *p[], int s, int r[], int c[], int m[], int n[])
```

其中 p 為待排序的指標陣列，s 為 p 的元素個數。假設 p[i] 指向的整數 a 位在二維陣列 X 中，r[i] 與 c[i] 分別代表 a 在 X 中的列註標 (row index) 與行註標 (column index)，m[i] 與 n[i] 代表 X 有 m[i] 列 (row)，n[i] 行 (column)。

函式 sort_p 須將陣列 p 依題目中指定的順序由小而大排好。
你可以利用 (修訂) 下面的 main function 進行檢測。評測時的 main function 不一定為此函式。

* main function (預期)
```cpp=
#include <stdio.h>

int main(){
  int a[10] = {3, 1, 2, 5, 5, 3, 2, 6, 0, 3};
  int *p[2] = {&a[5], &a[2]};
  int r[2] = {0, 1}, c[2] = {2, 1};
  int m[2] = {2, 2}, n[2] = {4, 3}; 
  sort_p(p, 2, r, c, m, n);

  for (int i = 0; i < 2; i++)
    printf("%d ", p[i] - &a[0]);
  printf("\n");

  return 0;
}
```
輸出

    2 5

* 實際使用的 main.c
```c=
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "sort_p.h"
#define MAXS 1024


int find(long v, long arr[], int n)
{
    for (int i = 0; i < n; i++)
        if (arr[i] == v)
            return i;
    return -1;
}

int main()
{
    int s;
    int *mat[MAXS];
    long offsets[MAXS];
    int *p[MAXS];
    int r[MAXS], c[MAXS];
    int h[MAXS], w[MAXS];

    scanf("%d", &s);
    for (int i = 0; i < s; i++)
    {
        scanf("%d %d %d %d", &h[i], &w[i], &r[i], &c[i]);
        mat[i] = (int *)malloc(sizeof(int) * h[i] * w[i]);
        for (int j = 0; j < h[i]; j++)
            for (int k = 0; k < w[i]; k++)
                scanf("%d", &mat[i][j * w[i] + k]);
        p[i] = &mat[i][r[i] * w[i] + c[i]];
        offsets[i] = p[i] - (int *)mat;
    }
    sort_p(p, s, r, c, h, w);
    for (int i = 0; i < s; i++)
    {
        int idx = find(p[i] - (int *)mat, offsets, s);
        assert(idx != -1);
        printf("%d ", idx);
    }
    puts("");

    return 0;
}
```
* sort_p.h
```c=
// r, c: row index, column index
// m, n: row count, column count
void sort_p(int *p[], int s, int r[], int c[], int m[], int n[]);
```

#### Sample Input 1

```
2
2 2 1 1
1 2
3 4
4 4 0 0
1 2 3 4
5 6 7 8
1 2 3 4
5 6 7 8
```

#### Sample Output 1

```
1 0
```


#### Sample Input 2

```
1
3 3 2 2
1 2 3
6 5 4
7 8 9
```

#### Sample Output 2

```
0
```


#### Sample Input 3

```
3
1 5 0 3
1 2 3 4 5
1 4 0 0
7 8 9 3
1 6 0 4
9 4 8 2 1 3
```

#### Sample Output 3

```
2 0 1
```

---

### 參考解答
> [name=博傑]
```c=
// 比較兩個向量字典序的函式，當回傳 1 的時候表示 p_a > p_b
// p: 指向向量開頭的 pointer
// offset: 向量兩元素之間的間隔
// cnt: 向量長度
// _a 與 _b 用來區分兩向量
int compare(int *p_a, int offset_a, int cnt_a, int *p_b, int offset_b, int cnt_b)
{
    // 還沒比到其中一邊的結尾
    while (cnt_a && cnt_b)
    {
        // 遇到不同的元素，回傳比較結果
        if (*p_a != *p_b)
            return *p_a > *p_b;
        // 移動兩個 pointer
        p_a += offset_a, p_b += offset_b;
        cnt_a--, cnt_b--;
    }
    // 前綴一樣，則長度較長者字典序較大
    return cnt_a > cnt_b;
}

// 交換兩整數
int swap(int *a, int *b)
{
    int t = *a;
    *a = *b;
    *b = t;
}

// 使用 compare 實作 bubble sort
void sort_p(int *p[], int s, int r[], int c[], int m[], int n[])
{
    for (int i = 0; i < s; i++)
    {
        for (int j = 0; j < s - i - 1; j++)
        {
            // 呼叫 compare 比較相鄰兩元素大小
            if (compare(
                    // 找到 p[j] 所屬的 column 開頭
                    p[j] - r[j] * n[j],
                    // n[j] 會是第 j 個二維陣列的寬度
                    // 也就是同一個 column 上面的相鄰兩元素距離
                    n[j],
                    // 二維陣列高度代表 column 長度
                    m[j],
                    // 對 p[j + 1] 的操作同上
                    p[j + 1] - r[j + 1] * n[j + 1],
                    n[j + 1],
                    m[j + 1]))
            {
                // 交換元素，注意每個陣列都需要交換
                int *t = p[j];
                p[j] = p[j + 1];
                p[j + 1] = t;
                swap(&r[j], &r[j + 1]);
                swap(&c[j], &c[j + 1]);
                swap(&m[j], &m[j + 1]);
                swap(&n[j], &n[j + 1]);
            }
        }
    }
}
```


> [name=映達]

```cpp=
#define swap(a, b) ((a) ^= (b) ^= (a) ^= (b))

int cmp(int *p, int pr, int ph, int pw, int *q, int qr, int qh, int qw)
{
	p -= pr * pw;
	q -= qr * qw;
	int d = 0;
	for (int i = 0; d == 0; ++i)
	{
		if (i >= ph || i >= qh)
		{
			d = ph - qh;
			break;
		}
		d = *(p + pw * i) - *(q + qw * i);
	}
	return d > 0;
}

void sort_p(int *p[], int s, int r[], int c[], int m[], int n[])
{
	for (int i = 0; i < s - 1; ++i)
	{
		for (int j = i; j < s; ++j)
		{
			if (cmp(p[i], r[i], m[i], n[i], p[j], r[j], m[j], n[j]))
			{
				int *tmp = p[i];
				p[i] = p[j];
				p[j] = tmp;
				swap(r[i], r[j]);
				swap(c[i], c[j]);
				swap(m[i], m[j]);
				swap(n[i], n[j]);
			}
		}
	}
}
```

---

### 評分
> * [測資載點](https://drive.google.com/file/d/17Ij3pclkm6tdHVOQJGcec_l_KqZ08Czm/view?usp=sharing)
> [name=博傑]

### 測資說明

- 共 60 筆測資，以 10 筆為一組，皆為隨機產生，每過一筆可得 0.5 分
- 限制
    1. 第一組 $s = 1$
    2. 第二組 $m[i] = 1$
    3. 其餘無特殊限制


