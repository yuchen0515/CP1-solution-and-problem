# Homework 5——解答

|     | 題目                 | 出題者         |
|:--- |:-------------------- |:-------------- |
| 1   | Number of Appearance | Judge Girl     |
| 2   | 危機！低醣少女       | 莊博傑         |
| 3   | lOI0                 | 莊博傑、陳映達 |
| 4   | 丟番圖               | 陳映達         |
| 5   | 「後宮王」羅伊德     | 林育辰         |

---

## Number of Appearance

> [name=Judge Girl]

### Description

Write a program to report the number of times a number N appears in another number M. These appearances may overlap.

請寫一支程式計算數字 $N$ 出現在另一個數字 $M$ 中的次數。出現的地方有可能會互相重疊。

#### Limits

- $10 \le N \le 99$
- $1000000 \le M \le 9999999$

### Input

Write a program to report the number of times a number $N$ appears in another number $M$. The number $N$ is between $10$ and $99$, and the number $M$ is between $1000000$ and $9999999$, inclusively.

請寫一支程式計算數字 $N$ 出現在另一個數字 $M$ 中的次數。出現的地方有可能會互相重疊。$N$ 是一個介於（包含）$10$ 到 $99$ 間的數。$Ｍ$ 是一個介於（包含）$1000000$ 到 $9999999$ 間的數。

### Output

The output has only one number, namely the number of times $N$ appears in $M$.

輸出僅有一個整數，代表 $N$ 在 $M$ 中出現的次數。

### Example Input 0

    90 9090999

### Example Output 0

    2

### Example Input 1

    11 1110111

### Example Output 1

    4

### Hint

題目搬運自 Judge Girl，[原題連結](https://judgegirl.csie.org/testdata/download/54)在此

### 參考程式
> [name=育辰]

```cpp=
#include <stdio.h>
#include <stdint.h>

int main(){
    int32_t n = 0 , m = 0, ans = 0;
    scanf("%d %d", &n, &m);

    int32_t ind_n = 0 , ind_m = 1, tpp = n;
    for (ind_n = 0 ; tpp ; ind_n++, tpp/=10, ind_m*=10);

    while (m){
        int32_t temp = m % ind_m;
        if (temp == n)
            ans += 1;

        m /= 10;
    }

    printf("%d\n", ans);

    return 0;
}
```

---

## 危機！低醣少女

> [name=博傑]

### Description

體重，那可是身為一位青春期的少女，不，就算是少年，也不能隨便公開的秘密，當然對於書記來說也不例外，然而隨著入秋，天氣也逐漸轉涼，豐盛的美食總是讓人忍不住會多來幾口，書記的體重也跟著水漲船高⋯⋯

> **「不行，低醣女孩的尊嚴可不能被這樣踐踏！」**

於是書記開始他的減肥計畫，經過一番深思熟慮後，書記決定要騎上她最近新買的電動腳踏車，踏上減肥之旅。

![](https://i.imgur.com/shQa6oy.jpg)

出遠門的第一步，首先是要規劃路線，為了讓減肥的效果更加顯著，所以她決定要騎附近的山路，順便接受大自然的薰陶，她是這樣決定路線的：

1. 這條山路的上升與下降的坡度剛好都成 45 度角，所以在道路上相距一個單位長的兩點，高度差也會恰好是一個單位長。並且我們可以用一連串的「上升」或「下降」來描述山路的情況。
2. 如果以 `1` 代表上升，`-1` 代表下降，則 `1 1 -1 -1` 就會形成如下的形狀：
   ![](https://oj.ujoj.cc/public/upload/1b4bf73d8f.png)
4. 為了維持節奏，書記希望它可以從整條山路當中找到一段「相鄰的上升高度與下降高度相等」的路段，因為她認為這樣可以達到更佳的減肥效果。  
   在這裡指的上升與下降高度相等是說，如果她每騎了 $n$ 個單位長的上坡，則接下來也有一段恰好為 $n$ 單位長的下坡。  
   舉個例子來說，`1 1 -1 -1` 剛好就滿足這樣的條件。
   而如果在後面緊接著一個符合條件的路段的話，長度可以一併算入，例如說 `1 -1 1 -1`，就會是由兩組 `1 -1` 組成，則長度為 `4`

可是書記家旁邊的這座山實在是非常的大，等她找到適合的路段時，冬天都要來了，那可不是適合騎車的天氣呢。  
現在，告訴你這個山路的形狀，請你寫個程式幫書記找出在符合她的要求的路段中，最長的一段長度是多少吧。

### Input

第一行為一個整數 $n$  
第二行為 $n$ 個以一個空白隔開的整數，並且裡面只會有 $1$ 跟 $-1$，代表
在這個位置的山路是上升或下降

#### Limits

$2 \le n \le 10^4$

#### Subtasks

|       | Limits       | Score |
|:----- |:------------ | -----:|
| #0    | $n \le 10$   |  $35$ |
| #1    | $n \le 10^2$ |  $35$ |
| #2    | $n \le 10^3$ |  $15$ |
| #3    | $n \le 10^4$ |  $15$ |
| total |              | $100$ |

### Output

請輸出一個整數於一行，代表在所有符合條件的路段中，最長的長度會是多少

### Example Input

```
4
1 1 -1 -1
```

### Example Output

```
4
```

### Example Input

```
4
1 -1 1 -1
```

### Example Output

```
4
```

### Example Input

```
5
1 -1 -1 1 1
```

### Example Output

```
2
```

### Example Input

```
2
-1 1
```

### Example Output

```
0
```

### Hint

1. 在第二筆範測當中，整條路線剛好都是以一個單位長交錯上升下降，所以輸出為 `4`。
1. 在第三筆範測當中，最長的一段是 `1 -1`，所以長度為 `2`，這裡需要留意的是，這路段是可以只取一部份的，也就是說下坡不一定要走完，上坡也不一定要從頭開始走。
2. 在第四筆範測中，因為是先從下坡開始，所以不符合書記所設定的條件，因此輸出為 `0`

### 參考程式

> [name=博傑]

```c=
#include <stdio.h>

int main()
{
    int U = 0; // 目前上升總長
    int D = 0; // 目前下降總長
    int curr, last = 0; // 當前數字與上一個值
    int n; // 道路總長
    int ans = 0, cnt = 0; // 答案與目前符合條件的最長長度

    scanf("%d", &n);
    for (int i = 0; i <= n; i++)
    {
        // 不是最後一個的話就直接讀進來
        if (i < n)
            scanf("%d", &curr);
        // 在最後一個位置補上虛擬的 1，強迫更新答案
        else
            curr = 1;
        // 如果開始往上升
        if (curr == 1)
        {
            // 前一個是下降，所以代表一個山坡的結束
            if (last == -1)
            {
                // 如果上升的沒有比較長，代表可以接在前面已找到的總長
                // e.g., 1 (1 -1) (1 1 -1 -1) 1
                // 上面有兩個括號括起來的區段，後面的跟前面的是相連的
                if (U <= D)
                    cnt += U * 2;
                // 如果上升的幅度比較大的話，代表沒辦法接在前面
                // e.g., 1 (1 -1) [1 (1 1 -1 -1)] 1
                // 上面以中括號括起來之區段，代表的就是目前的 U 和
                // D 在處理的區段，而小括號括起來的區段，代表的是符
                // 合條件的長度
                else
                    cnt = D * 2;
                // 將答案更新成 ans 與 cnt 當中較大者
                ans = ans > cnt ? ans : cnt;
                // 如果上升的幅度比下降的來得小，則代表後面的沒辦法接
                // cnt 歸零
                if (U < D)
                    cnt = 0;
                // 將 U 和 D 歸零，處理新的一段
                D = U = 0;
            }
            // 上升幅度加一
            U++;
        }
        else
        {
            // 下降幅度加一
            D++;
        }
        // 更新上一個數字
        last = curr;
    }
    // 輸出答案
    printf("%d\n", ans);

    return 0;
}
```

---

## lOI0

> [name=映達]

### Description

給定一堆的 $1$ 和 $0$，請你將它排列成可能的、最大的、$11$ 的倍數。

### Input

輸入共有兩行。  
第一行，輸入一個整數 $n$，代表接下來共有多少的 $1$ 或 $0$。  
第二行，輸入 $n$ 個數字，用空白隔開，這些數字只有可能是 $1$ 或 $0$。

#### Subtasks

|    | Limits | Score |
| :-- | :------ | ---: |
| #0 | $1 \le n \le 7$, 且保證可以排列成一個 $11$ 的倍數 | $35$ |
| #1 | $1 \le n \le 7$ | $35$ |
| #2 | $1 \le n \le 10^5$, 且保證可以排列成一個 $11$ 的倍數 | $15$ |
| #3 | $1 \le n \le 10^5$ | $15$ |
| total |  | $100$ |

### Output

輸出一個整數，代表所有 $1$ 或 $0$ 可能排列成的、最大的、$11$ 的倍數。  
**若排列完的數字前方若有多餘的 $0$，記得去除這些 $0$。**  
若是這些 $1$ 或 $0$ 無法排列成一個 11 的倍數，輸出 `-1` 。

### Example Input 0

```
4
1 0 0 1
```

### Example Output 0

```
1100
```

### Example Input 1

```
3
0 1 0
```

### Example Output 1

```
-1
```

### Example Input 2

```
21
1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0
```

### Example Output 2

```
101010101010101010101
```

### Hint

$11$ 的倍數有「 `奇位和` - `偶位和` = `11 的倍數` 」的特性。

例如 $40249$ ，檢查 $\left(4 + 2 + 9\right) - \left(0 + 4\right) = 11$ 是 $11$ 的倍數，因此 $40249$ 是 $11$ 的倍數。

### 參考程式

> [name=映達]

```cpp=
#include <stdio.h>

int main() {
    int n = 0;
    scanf("%d", &n);

    int o = 0, l = 0;
    while(n--) {
        int x;
        scanf("%d", &x);
        l += x;
        o += !x;
    }

    if(!l) {
        // 小心邊緣測資：輸入只有 0
        // 唯一可能出現有多餘前綴 0 的情況
        printf("0");
    } else if(l % 2) {
        // 如果有奇數個 1
        if(l < 11 || o < 10) {
            // 最少需要 11 個 1 和 10 個 0 交錯形成 11 的倍數
            printf("-1");
        } else {
            // 有多餘（> 11）的 1 通通放到數字的高位
            // （這裡多餘的 1 必定是偶數個，因此奇偶和會相等，相減為 0）
            while(l-- - 11) {
                printf("1");
            }
            // 1、0 交錯，奇偶和剛好差 11
            printf("101010101010101010101");
            // 有多餘（> 10）的 0 通通放到數字的低位
            while(o-- - 10) {
                printf("0");
            }
        }
    } else {
        // 當 1 有偶數個時全部排一起，奇偶和會相等，相減為 0
        while(l--) {
            printf("1");
        }
        // 0 全部放在低位
        while(o--) {
            printf("0");
        }
    }
}

```

---

## 丟番圖

> [name=映達]

### Description

請你計算一個超超超超超超長正整數 $m$ 是否為一個大於 $10$ 的質數 $p$ 的被數？

### Input

輸入共有兩行：  
第一行，輸入兩個整數，自然數 $n$ 與質數 $p$。  
第二行，輸入一個「$n$ 位數」的自然數 **$m$ 的「 reverse 」**。( e.g., $m = 7890$ 的話，會輸入 `0987` )

> 要一次讀取「一個位數」可以這樣寫：
> ```cpp
> int a;
> scanf("%1d", &a);
> ```

#### Subtasks

|    | Limits | Score |
| :--: | :------ | :---: |
| #0 | $1 \le n \le 10^3$, $p = 103$ | $30$ |
| #1 | $1 \le n \le 10^3$, $11 \le p \lt 10^8$ | $40$ |
| #2 | $1 \le n \le 10^6$, $11 \le p \lt 10^8$ | $30$ |
| total |  | $100$ |


### Output

請輸出 $m$ 是否為 $p$ 的倍數。  
是的話請輸出 `Yes`。不是的話則輸出 `No`。

### Example Input 0

```
100 85509869
5736254856397010238858256572704134956342359776094595057179093304419504446110754480098743661940820653
```

### Example Output 0

```
Yes
```

### Example Input 1

```
100 55516553
0307003232692434663657854125173407105750381299853752179937780762080614289950842462279640636747322693
```

### Example Output 1

```
No
```

### Example Input 2

```
55668 11
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 ... (all 1s to the end)
```

### Example Output 2

```
Yes
```


### Hint

#### 以下為本題「可能」用到的演算法與其推導

取模運算（$\text{ mod }$）有兩個重要的特性：

- $\left(a + b\right) \text{ mod } d = \left[\left(a \text{ mod } d\right) + \left(b \text{ mod } d\right)\right] \text{ mod } d$
- $ab \text{ mod } d = \left[\left(a \text{ mod } d\right)\left(b \text{ mod } d\right)\right] \text{ mod } d$

提供兩個相關的想法，希望可以激發同學的靈感。

#### 想法 1

一個自然數 $m$ 可以表示成 $m = \left(\left(\left(m_n\right) \times 10 + m_{n-1}\right)\times 10 + \cdots\right) \times 10 + m_1$

> e.g., $1234 = \left(\left(\left(1\right) \times 10 + 2\right) \times 10 + 3\right) \times 10 + 4$

再根據上方兩個特性計算 $m \text{ mod } d$，由最內層往外做（由高位往低位做）。

#### 想法 2

若 $m$ 為一個質數 $p$ 的倍數，則可以寫成 $m = 10a + b$ 也會是 $p$ 的倍數，其中 $b = m \text{ mod } 10$。（$p \ge 11$）  

> e.g., $1234 = 10\times123 + 4$

那麼 $\left(pa + pkb\right) - \left(10a + b\right)$ 也會是 $p$ 的倍數，其中 $k$ 是一整數。  

> 因為 $pa + pkb = p\left(a + kb\right)$ 是 $p$ 的倍數。兩個 $p$ 的倍數相減必為 $p$ 的倍數。

經過整理，

$\left(pa + pkb\right) - \left(10a + b\right) = \left(p - 10\right)a + \left(pk - 1\right)b = \left(p - 10\right)\left(a + xb\right)$

若 $x$ 為整數，則 $\left(a + xb\right)$ 亦為 $p$ 的倍數。

> 因為 $p$ 不小於 $10$，所以 $p$ 和 $p - 10$ 必定互質

根據 $\left(p - 10\right)x = pk - 1$，可以移項得到 $pk + \left(p - 10\right)(-x) = 1$。  
又 $\text{GCD}\left(p,\,p - 10\right) = 1$，根據[歐幾里德引理](https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%BC%95%E7%90%86)，該二元一次不定方程式存在整數解。
因此我們可以透過[擴展歐幾里得算法](https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)求得一組 $\left(k_0, x_0\right)$ 的整數解。

將 $x_0$ 帶回，得到 $a + x_0b$ 為 $p$ 的倍數。  
換句話說，要檢查 $m = 10a + b$ 是否為 $p$ 的倍數，可以檢查 $a + x_0b$ 是否為 $p$ 的倍數。

#### 舉個例子，以 $p = 11$, $m = 187$ 為例

求 $11k + \left(11 - 10\right)\left(-x\right) = 1$ 的整數解，得 $\left(k_0, x_0\right) = \left(0, -1\right)$。

$a + x_0b = a - b = 18 - 7 = 11$，驗證 $11 \text{ mod } 11 = 0$，因此 $187$ 是 $11$ 的倍數。

#### 其他的例子，$p = 13$, $m = 187$

求 $13k + \left(13 - 10\right)\left(-x\right) = 1$ 的整數解，得 $\left(k_0, x_0\right) = \left(1, 4\right)$。

$a + x_0b = a + 4b = 18 + 28 = 46$，驗證 $46 \text{ mod } 13 = 7$，因此 $187$ 不是 $13$ 的倍數。

### 參考程式

> [name=映達]

#### 想法 1

```cpp=
#include <stdio.h>

int main() {
    int n = 0, p = 0;
    scanf("%d %d", &n, &p);

    int r = 0, b = 1;  // r: 餘數, b: 10 的冪次 mod p
    for(int t = 0; n--; b = b * 10 % p) {
        scanf("%1d", &t);
        r = (r + t * b % p) % p;
    }

    printf("%s\n", r % p ? "No" : "Yes");
}
```

- $m$ 是每一個位數乘上 10 的冪次的和。  
  > e.g., $1234 = 1 \times 10^3 + 2 \times 10^2 + 3 \times 10^1 + 4 \times 10^0$
  >
  根據 $\bmod$ 加法的特性，我們可以將每一個位數分別處理。
- 每一個位數皆是一個乘法，根據 $\bmod$ 乘法的性質，也可以將他們分開處理。
- 需要注意的是，$10^n$ 會 overflow，因此不能直接計算 $10^n \bmod p$，利用乘法性質可以這樣做：$10^n \bmod p = ((10^{n-1} \bmod p) \times 10) \bmod p$。  
  並用 $b$ 將前一次的狀態（$10^{n-1} \bmod p$）記錄下來，如使一來便不用每次皆重新計算。

#### 想法 2

```cpp=
#include <stdio.h>

int main() {
    int n = 0, p = 0;
    scanf("%d %d", &n, &p);

    int q = p - 10, x = 1;
    // 擴展歐幾里得算法
    for(int _r = p, r = q, _x = 0; r != 1;) {
        int temp = 0;

        temp = x;
        x = _x - (_r / r)*x;
        _x = temp;

        temp = r;
        r = _r % r;
        _r = temp;
    }
    x *= -1;

    int r = 0;
    for(int t = 0; n--;) {
        scanf("%1d", &t);
        r += t;
        r = r/10 + r%10*x%p;
    }

    printf("%s\n", r % p ? "No" : "Yes");
}
```

兩種做法皆可 AC，執行時間也幾乎相等。第二種做法限制較多，但可以認識擴展歐幾里得算法，因此皆提供給同學參考。

---

## 「後宮王」羅伊德
> [name=育辰]

### Description

傳說中，在RPG大作主角都有「後宮王」的外掛 *BUFF*
>「情意迸發非罪也，我要一個攻九個！」

羅伊德 是克洛斯貝爾支援課的隊長\
其溫文憨厚的形象深植女孩的心中\
夜裡，此起彼落的嬉鬧聲，羨煞了多少人？\
\
一日，四季遞嬗，萬物繁盛、百花齊放的春日來臨。\
他——狩獵的季節又來了！\
為了繼承他死去的哥哥蓋伊瀕死前的遺志「一男多女」\
正腳踏實地的執行著...\
\
於是，他依序為身旁的女性，艾莉、緹歐、琪雅、諾艾爾、莉夏...列出一個「攻略」，若有意願攻略則標記為 $1$，否則為 $0$

假設今天有九個要記錄，則儲存為下列形式：
$$n = 101100100$$
第一位數為 $0$，表示對其名單第一位沒興趣\
第二位數為 $0$，同上\
第三位數為 $1$，表示其欲攻略\
$\ \ \vdots$\
依此類推
> 當然，在多元的社會氛圍下，羅伊德的名單中**不一定**只有女性

羅伊德會根據以下的考量，更改其攻略的意願：
1. 如果朋友同時對該對象有興趣，則其不攻略(改為0)
2. 如果損友同時對該對象有興趣，則其必攻略(改為1)
> **考量順序 $1 > 2$**\
> 因此若朋友有興趣，損友也有興趣，則羅伊德不參與(0)

蘭迪是他的好同事，好朋友，曾為最強獵兵團「赤色星座」成員之一，但卻是個萬年魯蛇，近期也想找個歸宿，於是也按照羅伊德的名單順序列出自己的意願狀況儲存進 $p$ 中。 (partner)

約書亞過去與其有愛恨上的糾葛，先不論兩人複雜的關係，目前姑且算是損友，未來發展尚不曉得，總之約書亞也和羅伊德列了相同的名單順序儲存進 $h$ 中。 (hate)

你接下了羅伊德的**S級**搜查任務！！\
今給定 $n$, $p$, $h$，其每一位數表示其特定編號的意願狀態，並依上述改變羅伊德最終攻略之意願為 $r$，請寫出一個程式完成上述條件，最後先以上述形式輸出結果 $r$，再以一行輸出其最終想攻略的編號順序(由大到小，名單編碼以 $1$ 為始，並非 $0$)。

> 題幹之人物名稱和部分設定取自日本Falcom出產「碧之軌跡」(為零之軌跡後作)，和其設定並非完全相符。


### Subtask

| Case   | Describe     | Per. |
|:------ |:------------ | ----:|
| #1     | 輸入保證只有 $1$ 位數 |  10% |
| #2     | 輸入位數不限，沒有 損友、朋友同時有意願的情況，也沒有 $r=0$的情況| 20%|
| #3     | 輸入位數不限，沒有 $r=0$ 的情況   |  30% |
| #4     | 無特殊限制   |  40% |
| **Total** |              | 100% |



### Input
每行依序給定 $n$, $p$, $h$，每一位數數字只可能是 $0$ 或 $1$\
數字不超過 $2^{31}-1$，位數**最多**九位數，最少一位數。
> 因三人名單一致、順序一樣，因此三人名單的**位數相同**


### Output
請先以一行同 $n$, $p$, $h$ 儲存形式，輸出其結果 $r$，若最高位為 $0$ 該位數無需輸出，直到遇到第一個 $1$ 開始輸出（$1$ 的最高位)，若無「有意願」攻略編號，則直接輸出 $0$。\
\
再以一行由編號大到小輸出羅伊德最終「有意願」攻略之編號，並以空格隔開，最後需有換行，若無「有意願」攻略之編號，請輸出 $-1$。


### Example Input 0
    100110010
    101100110
    010111100

### Example Output 0
    10011000
    8 5 4

### Example Input 1
    00100110
    00100110
    00100100

### Example Output 1
    0
    -1
    
    
### Example Input 2
    10110011
    00101110
    11100000


### Example Output 2
    11010001
    8 7 5 1

### Example Input 3
    110010111
    111110011
    101011000

### Example Output 3
    1100
    4 3


### Hint
* 有多種做法，但由於輸出要求，建議依照題目的方式儲存輸出較簡單，本題想告知的概念是可運用 digit 去儲存狀態，數值並非只能代表一種狀態，如 `0`為剪刀，`1`為石頭等...而是一個 $9$ 位數的數值，可以同時儲存 $9$ 種狀態
* 在程設(二)位元運算中會有類似概念，這邊運用**迴圈**和 `%` `/` 去處理即可完成
* 雖然輸入有 `010111100`看似 $9$ 位數，但同學讀入變數時應為 `10111100`，必須小心處理！
* 因本題難度稍難，處理時注意若用 `/`取該位數，該位數以上的數值必須利用 `%` 清除再 `/`，請格外注意當 `i=9` 時，不須用 `%`清除，否則會有 `overflow` 的問題
* 建議以上處理時，將過程印出來以確認程式是否寫對
* 範例測資0：
    $$n = 100110010$$
    $$p = 101100110$$
    $$h = 010111100$$
    1. 從最右開始調查其意願，對於第一個對象，三人皆為 `0` 因此其意念堅貞不渝，最終還是 `0`
    2. 第二位數羅伊德為 `1`，他的好朋友蘭迪為 `1`，損友約書亞為 `0`，根據準則一，他不希望和好朋友爭鬥，因此最終改變為 `0`
    3. 第三位數依序為 `0` `1` `1`，根據準則順位，雖然損友有意願羅伊德會想搶，但他非常重視朋友，因此根據準則一，最終仍是 `0` (無意願)
    4. 第四位數依序為`0` `0` `1`，根據準則二，損友想要的他也要，因此由 `0` 改為 `1`
    5. 第五位數為 `1` `0` `1`，最終仍為 `1`
    6. 第六位數為 `1` `1` `1`，由於朋友想要的他不想搶，改為`0`
    7. 第七位數為 `0` `1` `0`，最終仍為 `0`
    8. 第八位數為 `0` `0` `1`，損友想要的他也要，因此最終意願為 `1`
    9. 第九位數為 `1` `1` `0`，朋友要的他不搶，因此最終為`0`
    綜合上述，得到： $$r = 010011000$$
    由左至右遇到第一個 $1$ 開始輸出，因此第一行輸出 `10111000`，第二行則依編號大至小，輸出 `8` `5` `4` 
* 範例測資1：
    $$n = 00100110$$
    $$p = 00100110$$
    $$h = 00100100$$
    共八位數，由於朋友想要的損友剛好也要，顧及朋友的感受，羅伊德都不參與爭鬥，或朋友想要的自己也想要，但他很看重朋友還是不會爭搶，本測資恰巧為下列結果：$$r=00000000$$
    * 第一行輸出 `0`，第二行因無編號可輸出，輸出 `-1`


### 參考程式
> [name=育辰]

```cpp=
#include <stdio.h>
#include <stdint.h>

int main(){
    int32_t n = 0 , p = 0 , h = 0;
    int32_t r = 0, mul = 1, i = 0;

    scanf("%d %d %d", &n, &p, &h);

    //為避免雖有8位數但第8位為0情況，由低往高處理
    for (i = 1 ; i <= 9 ; i++){
        int32_t n_b = n , p_b = p, h_b = h;

        //清除該位數以上的數值
        if (i != 9){
            n_b %= (mul * 10);
            p_b %= (mul * 10);
            h_b %= (mul * 10);
        }
        
        //清除該位數以下的數值
        n_b /= mul;
        p_b /= mul;
        h_b /= mul;

        //三個數都取得該位數，單純判斷
        
        //朋友不想要，損友想要，我也要
        if (p_b == 0 && h_b == 1)
            r += (mul);
        //朋友不想要，損友也不要，就按照我的意思
        else if (p_b == 0 && h_b == 0)
            r += (n_b * mul);
            
        if (i != 9)
            mul *= 10;
    }
    
    //儲存結果為0，表示都無意願
    if (r == 0)
        printf("0\n-1\n");
    else{
        printf("%d\n", r);
        int32_t blank = 0;

        //由高往低處理輸出即可
        for (i = 9 ; i >= 1 ; i--, mul/=10){
            if (i != 9)
                r %= (mul * 10);

            if (r / mul){
                if (blank) 
                    printf(" ");

                printf("%d", i);
                blank = 1;
            }
        }
        printf("\n");
    }

    return 0;
}
```

* 從低位數往最高位數跑，每次利用 `/` `%` 取出該digit的數值
* 三條n,h,p同時進行，並依照順位用兩個判斷式去檢查
* 結果直接用乘的然後加進 `r`，最後從最高位往後印出即可！
